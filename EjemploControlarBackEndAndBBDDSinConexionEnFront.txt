Index.js

import { useState, useContext } from "react";
import { useRouter } from "next/router";
import Button from "../../Button";
import styles from "./styles.module.css";
import ReCAPTCHA from "react-google-recaptcha";
import { sendEmail } from "../../../services/RequestPasswordService";
import ErrorIcon from "@mui/icons-material/Error";

/*
    properties:
        formDestination (file where user must be sent)
        formType (signIn || signUp)
        formFields (array of objects with the following properties: name, type, placeholder)
        complementaryText (informative text to help user)
    */

/**
 * Lógica del formulario RequestPasswordForm
 * Añadimos ReCAPTCHA v2(plugin de Google para controlar acceso de bots y no sobrecargar el correo)
 * Botón Enviar para generar el correo
 * Botón Cancelar para volver a login
 * @param {*} props
 * @returns HTML de RequestPasswordForm con ReCAPTCHA y botones
 */
export default function Form(props) {
  const [email, setEmail] = useState("");
  const [isVerified, setIsVerified] = useState(false);

  const [emailError, setEmailError] = useState(false);
  const [errorMessage, setErrorMessage] = useState("");
  const [addClicked, setAddClicked] = useState(false);
  const [backendOrDDBBConnectionError, setBackendOrDDBBConnectionError] =
    useState(false);

  /**
   * Manejador del ReCAPTCHA
   * Setteamos la variable isVerified = true si se cumple el ReCAPTCHA
   * @param {*} response
   */
  const handleVerification = (response) => {
    setIsVerified(true);
  };

  // Ruteado para poder ir después a login
  const router = useRouter();

  /**
   * Manejador de Enviar
   * Llamamos a la función handleSendEmail al pulsar el botón
   * @param {*} event
   */
  function handleSubmit(event) {
    event.preventDefault();
    handleSendEmail();
  }

  /**
   * Función asincrona que genera el email con la contraseña de recuperación
   * Mostramos alerta si se cumple o no sendEmail(email)
   */
  const handleSendEmail = async () => {
    let errorDevueltoBack = false;
    let errorConexionBackEndOrBBDD = false;
    try {
      const response = await sendEmail(email);
      if (response.status === 409) {
        setEmailError(true);
        setErrorMessage(response.errorMessage);
        setAddClicked(true);
        errorDevueltoBack = true;
      } else if (response.status === 500) {
        setBackendOrDDBBConnectionError(true);
        setErrorMessage(response.errorMessage);
        setAddClicked(true);
        errorConexionBackEndOrBBDD = true;
      } else {
        errorDevueltoBack = false;
        errorConexionBackEndOrBBDD = false;
      }

      if (!errorDevueltoBack && !errorConexionBackEndOrBBDD) {
        handleUpdate();
      }
    } catch (error) {
      console.log("Error", error);
    }
  };

  /**
   * Manejador de Cancelar
   * Vamos a la página login al pulsar el botón Cancelar
   */
  function handleCancel() {
    router.push("/login");
  }

  function handleUpdate() {
    router.push("/updatePassword");
  }

  return (
    <>
      <form
        action={props.formDestination}
        method="post"
        onSubmit={handleSubmit}
      >
        <label
          className={styles.Label}
          htmlFor={`${props.formType}`}
        >{`${props.complementaryText}`}</label>
        <br />

        {props.formFields.map((field, index) => (
          <div key={`${props.formType}-${field.name}-${index}`}>
            <input
              required
              className={styles.FormInput}
              type={field.type}
              name={field.name}
              placeholder={field.placeholder}
              onChange={(e) => setEmail(e.target.value)}
            />
          </div>
        ))}

        {(emailError ||
          backendOrDDBBConnectionError ||
          errorMessage.length !== 0) && (
          <>
            <p className={styles.errorMessage}>
              <ErrorIcon fontSize="medium" color="error" />
              Error: {errorMessage}
            </p>
          </>
        )}

        <ReCAPTCHA
          sitekey="6Ldj3gUpAAAAAHkBEYxhrW8TF4vZzKVYm3aKoNNG"
          onChange={handleVerification}
        />

        <Button
          name={props.formType}
          className={styles.MainButton}
          key={`${props.formType}-btn`}
          type="submit"
          disabled={!isVerified}
        >
          Enviar
        </Button>

        <Button
          name={props.formType}
          className={styles.MainButton}
          onClick={handleCancel}
        >
          Cancelar
        </Button>
      </form>
    </>
  );
}

Para el usuario:

async function verifyLogin() {
    // Solucionamos el bug de múltiples alertas si pulsamos el botón mas de una vez
    if (buttonDisabled) {
      // Si el botón ya está deshabilitado, no hacemos nada
      return;
    }
    setButtonDisabled(true);

    let errorDevueltoBack = false;
    let errorConexionBackEndOrBBDD = false;
    let usuarioExiste = false;

    let userVerificado = false;
    let modify;
    let personaId;
    let userId;
    let token;
    // Si no hay backend se asume que el usuario es correcto. CAMBIAR ESTO CUANDO SE TENGAN USUARIOS

    if (!CHECK_LOGIN) {
      console.log("Sin CHECK_LOGIN");
      const permissionsObject = {
        permisosID: 3,
        ausencias: true,
        dar_alta: true,
        dar_baja: true,
        listado_facturacion: true,
        modificar_equipo: true,
        modificar_informacion: true,
        modulo_operaciones: true,
        subir_csr: true,
        tls: true,
        ver_personas_a_cargo: true,
        verse_a_si_mismo: true,
        ver_personas: true,
        ver_config: true,
        ver_maestros: true,
        ver_logs: true,
      };
      try {
        let responseLogin = await credentialsOK(
          process.env.NEXT_PUBLIC_DEVELOPMENT_ACCOUNT,
          process.env.NEXT_PUBLIC_DEVELOPMENT_PASSWORD
        );

        console.log("login: ", responseLogin);

        if (responseLogin.status === 409) {
          setFormError(true);
          setErrorMessage(responseLogin.errorMessage);
          setAddClicked(true);
          errorDevueltoBack = true;
        } else if (responseLogin.status === 500) {
          setBackendOrDDBBConnectionError(true);
          setErrorMessage(responseLogin.errorMessage);
          setAddClicked(true);
          errorConexionBackEndOrBBDD = true;
        } else {
          errorDevueltoBack = false;
          errorConexionBackEndOrBBDD = false;
          usuarioExiste = true;
        }

        if (
          !errorDevueltoBack &&
          !errorConexionBackEndOrBBDD &&
          usuarioExiste
        ) {
          userVerificado = responseLogin.success;
          modify = responseLogin.modify;
          personaId = responseLogin.personaID;
          userId = responseLogin.usuarioID;
          token = responseLogin.tokenUser;

          localStorage.setItem("token", token);
          localStorage.setItem("permission", JSON.stringify(permissionsObject));
          localStorage.setItem("userId", userId);
          localStorage.setItem("personaId", personaId);
          localStorage.setItem("user", formData.email);

          console.log("desarrollo");
          userVerificado = true;
        }
      } catch (error) {
        console.log("Error", error);
      }
    } else {
      console.log("Con CHECK_LOGIN");
      try {
        let responseLogin = await credentialsOK(
          formData.email,
          formData.password
        );

        console.log("login: ", responseLogin);
        if (responseLogin.status === 409) {
          console.log("ERROR 409");
          setFormError(true);
          setErrorMessage(responseLogin.errorMessage);
          setAddClicked(true);
          errorDevueltoBack = true;
        } else if (responseLogin.status === 500) {
          console.log("ERROR 500", responseLogin);
          setBackendOrDDBBConnectionError(true);
          setErrorMessage(responseLogin.errorMessage);
          setAddClicked(true);
          errorConexionBackEndOrBBDD = true;
        } else {
          errorDevueltoBack = false;
          errorConexionBackEndOrBBDD = false;
          usuarioExiste = responseLogin.success;
        }

        console.log("usuarioExiste: ", usuarioExiste);

        if (
          usuarioExiste === false &&
          errorDevueltoBack === false &&
          errorConexionBackEndOrBBDD === false
        ) {
          setErrorMessage("Email o contraseña no son correctos");
          setAddClicked(true);
        }

        if (
          !errorDevueltoBack &&
          !errorConexionBackEndOrBBDD &&
          usuarioExiste
        ) {
          userVerificado = responseLogin.success;
          modify = responseLogin.modify;
          personaId = responseLogin.personaID;
          userId = responseLogin.usuarioID;
          token = responseLogin.tokenUser;

          localStorage.setItem("token", token);
          const permission = await fetchPermissions(formData.email);
          localStorage.setItem("permission", JSON.stringify(permission));
          localStorage.setItem("userId", userId);
          localStorage.setItem("personaId", personaId);
          localStorage.setItem("user", formData.email);
        }
      } catch (error) {
        console.log("Error", error);
      }
    }

    // Si el usuario se verifica se actualiza el contexto y se redirige a la página principal
    if (userVerificado && !modify) {
      console.log("Credenciales correctas");
      //CookiesManagment("delete", 21);   <--- cookies para la gestion de usuario

      // Generar id único
      const sesionId = uuidv4();
      // Crear cookies de sesión
      CookiesManagment("CREATE", sesionId);

      router.push("/");
    } else if (userVerificado && modify) {
      setErrorMessage(
        "No puedes acceder a tu cuenta hasta que cambies tu contraseña. Por favor, actualiza tu contraseña para continuar"
      );
    } else {
      console.log("Credenciales incorrectas");
    }
    setButtonDisabled(false); // Habilitar el botón después de mostrar la alerta
  }


Esto es el service:

import axios from "axios";
import { API_URL } from "../context/constants";

export async function sendEmail(email) {
  const url = API_URL.replace("#", "email");
  const token = localStorage.getItem("token");

  const headers = {
    "Content-Type": "text/plain; charset=utf-8",
    Authorization: "Bearer " + token,
  };

  // CORS
  const corsConfig = {
    withCredentials: false, // Puede ser necesario si estás manejando cookies
    headers: {
      "Access-Control-Allow-Origin": "http://localhost:3000", // URL de frontend
    },
  };

  try {
    const response = await axios.post(url + "send-email", email, {
      headers: headers,
    });
    return response.data;
  } catch (error) {
    if (error.response) {
      return {
        errorMessage: error.response.data.message,
        status: error.response.status,
      };
    } else {
      return {
        errorMessage:
          "Se ha producido un error inesperado. Por favor, inténtalo de nuevo más tarde",
        status: 500,
      };
    }
  }
}

tengo que ver el if de service 